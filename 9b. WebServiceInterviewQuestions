Source 1: http://www.journaldev.com/9193/web-services-interview-questions-soap-restful
1.	What is a Web Service?
Web Services work on client-server model where client applications can access web services over the network. Web services provide endpoint URLs and expose methods that can be accessed over network through client programs written in java, shell script or any other different technologies.
Web services are stateless and doesn’t maintain user session like web applications.

2.	What are the advantages of Web Services? RRR
Some of the advantages of web services are: (interoperability, Reusability, Loose Coupling, Easy maintenance)
        ◦ Interoperability: Web services are accessible over network and runs on HTTP/SOAP protocol and uses XML/JSON to transport data, hence it can be developed in any programming language. Web service can be written in java programming and client can be PHP and vice versa.
        ◦ Reusability: One web service can be used by many client applications at the same time.
        ◦ Loose Coupling: Web services client code is totally independent with server code, so we have achieved loose coupling in our application.
        ◦ Easy to deploy and integrate, just like web applications.
        ◦ Multiple service versions can be running at same time.
 
3.	What are different types of Web Services?
There are two types of web services:
        1. SOAP Web Services: Runs on SOAP protocol and uses XML technology for sending data.
        2. Restful Web Services: It’s an architectural style and runs on HTTP/HTTPS protocol almost all the time. REST is a stateless client-server architecture where web services are resources and can be identified by their URIs. Client applications can use HTTP GET/POST methods to invoke Restful web services.

4.	What is SOAP?
SOAP stands for Simple Object Access Protocol. SOAP is an XML based industry standard protocol for designing and developing web services. Since it’s XML based, it’s platform and language independent. So our server can be based on JAVA and client can be on .NET, PHP etc. and vice versa.

5.	What are advantages of SOAP Web Services? RRR
SOAP web services have all the advantages that web services has, some of the additional advantages are:
        ◦ WSDL document provides contract and technical details of the web services for client applications without exposing the underlying implementation technologies.
        ◦ SOAP uses XML data for payload as well as contract, so it can be easily read by any technology.
        ◦ SOAP protocol is universally accepted, so it’s an industry standard approach with many easily available open source implementations.

6.	What are disadvantages of SOAP Web Services? RRR
Some of the disadvantages of SOAP protocol are:
        ◦ Only XML can be used, JSON and other lightweight formats are not supported.
        ◦ SOAP is based on the contract, so there is a tight coupling between client and server applications.
        ◦ SOAP is slow because payload is large for a simple string message, since it uses XML format.
        ◦ Anytime there is change in the server side contract, client stub classes need to be generated again.
        ◦ Can’t be tested easily in browser

7.	What is WSDL?
WSDL stands for Web Service Description Language. WSDL is an XML based document that provides technical details about the web service. Some of the useful information in WSDL document are: method name, port types, service end point, binding, method parameters etc.

8.	What are different components of WSDL? 
Some of the different tags in WSDL xml are:
        ◦ xsd:import namespace and schemaLocation: provides WSDL URL and unique namespace for web service.
        ◦ message: for method arguments
        ◦ part: for method argument name and type
        ◦ portType: service name, there can be multiple services in a wsdl document.
        ◦ operation: contains method name
        ◦ soap:address for endpoint URL.
Note: For more detail and examples check: https://www.w3schools.com/xml/xml_wsdl.asp


9.	What is UDDI?
UDDI is acronym for Universal Description, Discovery and Integration. UDDI is a directory of web services where client applications can lookup for web services. Web Services can register to the UDDI server and make them available to client applications.
Note: Different businesses publishes their web services on UDDI so that other business can lookup for it and to get complete information about the published web service. 

10.	What is difference between Top Down and Bottom Up approach in SOAP Web Services?
In Top Down approach first WSDL document is created to establish the contract between web service and client and then code is written, it’s also termed as contract first approach. This is hard to implement because classes need to be written to confirm the contract established in WSDL. Benefit of this approach is that both client and server code can be written in parallel.
In Bottom Up approach, first web service code is written and then WSDL is generated. It’s also termed as contract last approach. This approach is easy to implement because WSDL is generated based on code. In this approach client code have to wait for WSDL from server side to start their work.

11.	What is REST Web Services?
REST is the acronym for REpresentational State Transfer. REST is an architectural style for developing applications that can be accessed over the network. REST architectural style was brought in light by Roy Fielding in his doctoral thesis in 2000.
REST is a stateless client-server architecture where web services are resources and can be identified by their URIs. Client applications can use HTTP GET/POST methods to invoke Restful web services. REST doesn’t specify any specific protocol to use, but in almost all cases it’s used over HTTP/HTTPS. When compared to SOAP web services, these are lightweight and doesn’t follow any standard. We can use XML, JSON, text or any other type of data for request and response.

12.	What are advantages of REST web services? RRR
Some of the advantages of REST web services are: (Only HTTP, multiple format, loose coupled, easy maintenance, lightweight due to JSON support, can support wide variety of clients)
        ◦ Learning curve is easy since it works on HTTP protocol
        ◦ Supports multiple technologies for data transfer such as text, xml, json, image etc.
        ◦ No contract defined between server and client, so loosely coupled implementation.
        ◦ REST is a lightweight protocol
        ◦ REST methods can be tested easily over browser.

13.	What are disadvantages of REST web services? RRR
Some of the disadvantages of REST are:
        ◦ Since there is no contract defined between service and client, it has to be communicated through other means such as documentation or emails.
        ◦ Since it works on HTTP, there can’t be asynchronous calls.
        ◦ Sessions can’t be maintained. (It is recomemded.)
Note: Asynchronous call are which in which the browser is not blocked. Like, once a http request is send then browser javascript engine is still working and it does not block until response is received. Sadly, all rest calls are synchronous.

14.	What is a Resource in Restful web services?
Resource is the fundamental concept of Restful architecture. A resource is an object with a type, relationship with other resources and methods that operate on it. Resources are identified with their URI, HTTP methods they support and request/response data type and format of data.
Note: Anything that is returned by processing a rest web service request. Like, employee object as response of the web service. Each resource is mapped by a URI through which it is exposed to client. 

15.	What are different HTTP Methods supported in Restful Web Services?
Restful web services supported HTTP methods are – GET, POST, PUT, DELETE and HEAD.

16.	Compare SOAP and REST web services? RRR
Compare on the following pointers:
1.	Soap is protocol layer over HTTP while rest is an architecture only uses HTTP
2.	Message or payload type like XML, JSON
3.	WSDL or not
4.	UDDI (primarily SOAP based, I guess we can use for Rest too)
5.	Heavy and light weight
6.	Soap directly exposes methods through WSDL, while Rest exposes the resources through endpoint but no concept of WSDL. 
7.	Soap tightly coupled as it has contract while rest is loosely coupled. 
8.	Soap hard to maintain as any change in soap web service leads to changes in client stubs also while methods can be changed by keeping the end points same. 
9.	Soap can be tested using SoapUI while rest can be tested using Postman. 


17.	What are different ways to test web services?
SOAP web services can be tested programmatically by generating client stubs from WSDL or through software such as Soap UI.
REST web services can be tested easily with program, curl commands and through browser extensions. Resources supporting GET method can be tested with browser itself, without any program.

18.	Can we maintain user session in web services?
Technically, we can have state full web service but that would be against the rest architecture. Having session in web service will hamper scalability. 

19.	What is difference between SOA and Web Services? RRR
Service Oriented Architecture (SOA) is an architectural pattern where applications are designed in terms of services that can be accessed through communication protocol over network. SOA is a design pattern and doesn’t go into implementation.
Web Services can be thought of as Services in SOAP architecture and providing means to implement SOA pattern.

20.	What is the use of Accept and Content-Type Headers in HTTP Request? 
These are important headers in Restful web services. Accept headers tells web service what kind of response client is accepting, so if a web service is capable of sending response in XML and JSON format and client sends Accept header as “application/xml” then XML response will be sent. For Accept header “application/json”, server will send the JSON response.
Content-Type header is used to tell server what is the format of data being sent in the request. If Content-Type header is “application/xml” then server will try to parse it as XML data. This header is useful in HTTP Post and Put requests.

21.	How would you choose between SOAP and REST web services? RRR
Web Services work on client-server model and when it comes to choose between SOAP and REST, it all depends on project requirements. Let’s look at some of the conditions affecting our choice:
        ◦ Do you know your web service clients beforehand? If Yes, then you can define a contract before implementation and SOAP seems better choice. But if you don’t then REST seems better choice because you can provide sample request/response and test cases easily for client applications to use later on.
        ◦ How much time you have? For quick implementation REST is the best choice. You can create web service easily, test it through browser/curl and get ready for your clients.
        ◦ What kind of data format are supported? If only XML then you can go with SOAP but if you think about supporting JSON also in future then go with REST.

22.	What is JAX-WS API?
JAX-WS stands for Java API for XML Web Services. JAX-WS is XML based Java API to build web services server and client application. It’s part of standard Java API, so we don’t need to include anything else which working with it. Refer to JAX-WS Tutorial for a complete example.

23.	Name some frameworks in Java to implement SOAP web services?
Apache axis and apache CFX. (They are not implementation of JAX-WS)

24.	How to get WSDL file of a SOAP web service? RRR
WSDL document can be accessed by appending? wsdl to the SOAP endoint URL. In above example, we can access it at http://localhost:8888/testWS?wsdl location.

25.	What is JAX-RS API?
Java API for RESTful Web Services (JAX-RS) is the Java API for creating REST web services. JAX-RS uses annotations to simplify the development and deployment of web services. JAX-RS is part of JDK, so you don’t need to include anything to use it’s annotations.

26.	Name some implementations of JAX-RS API?RRR
There are two major implementations of JAX-RS API.
        1. Jersey: Jersey is the reference implementation provided by Sun. For using Jersey as our JAX-RS implementation, all we need to configure its servlet in web.xml and add required dependencies. Note that JAX-RS API is part of JDK not Jersey, so we have to add its dependency jars in our application.
        2. RESTEasy: RESTEasy is the JBoss project that provides JAX-RS implementation.

27.	Name important annotations used in JAX-RS API? 
Some of the important JAX-RS annotations are:
        ◦ @Path: used to specify the relative path of class and methods. We can get the URI of a webservice by scanning the Path annotation value.
        ◦ @GET, @PUT, @POST, @DELETE and @HEAD: used to specify the HTTP request type for a method.
        ◦ @Produces, @Consumes: used to specify the request and response types.
        ◦ @PathParam: used to bind the method parameter to path value by parsing it.

28.	What is the use of @XmlRootElement annotation? RRR
XmlRootElement annotation is used by JAXB to transform java object to XML and vice versa. So we have to annotate model classes with this annotation. We denote this annotation on the class. 

29.	How to set different status code in HTTP response? RRR
2xx Success
a.	200 OK
b.	201 Created
c.	202 Acceoted, but not yet handled right now. 
d.	204 No Content. Request is processed but the client does not need to go to another page.
3xx Redirection
e.	304 Not Modified: A good example when browser sends request for asking if the cached copy is still fresh. Then, 304 indicates that the cache copy browser has in not modified. 
4xx Client Error
f.	400 Bad Request: It is returned when server does not understand the request due to some reason and poor syntax is a common reason. 
g.	401 Unauthorized: As the name suggest, when the request lacks proper authentication credential then 401 is returned. 
h.	403 Forbidden: This response is given when server refuses to process the request with a reason, if it wishes to make public, in the response payload. 403 is not for authentication but it is for authorization. 
i.	404 Not Found
j.	406 Not Acceptable: returned when server cannot produced response in the format mentioned in the content negotiation as part of request header. 
k.	409 Conflict: This response comes when server find a conflict with the current state of resource asked or conflict in any rules setup. Like server might give this response if you try to upload a file which is older then the existing file provided its not allowed according to the rules set. 
l.	415 Not Supported media type: Server return this response code when the request payload format type is not supported. 
5xx Server Error
m.	500 Internal Server Error: server cannot process request due to unknown reason. 
n.	503 Service Unavailable: Server cannot accept request due to some reason.

Source 2: https://www.javatpoint.com/web-services-interview-questions
30.	How does a web service work?
A web service is used to communicate among various applications by using open standards such as HTML, XML, WSDL, and SOAP. You can build a Java-based web service on Solaris that is accessible from your Visual Basic program that runs on Windows. You can also use C# to build new web services on Windows that can be invoked from your web application that is based on JavaServer Pages (JSP) and runs on Linux.

31.	What is the advantage of XML in web service? 
Although, JSON is light weight and easy to be loaded in javascript, XML has support for XML schema and namespaces. XML is supported by all the technologies. 

32.	Explain the loosely coupled architecture of web services. RRR
Web service can be changed by making the URL same as before will not need client to be changed. This way we need not to update the client as web service update. This is what we call loosely coupled behavior. This feature makes the web service to be easily maintained. 

33.	What do you mean by synchronicity? RRR
Synchronicity is used to bind the client to the execution of the service. In synchronous invocations, the client blocks and waits for the service to complete its operation before continuing. On the other hand, synchronous operations facilitate a client to invoke a service and then execute other functions.
Note: This is related to synchronous http calls. Web service cannot accomplish asynchronous call. 

Source 3: https://career.guru99.com/top-50-web-services-interview-questions/


34.	Give me an example of real web service?
Google Map API is one big example of web service. I have personally used it while working in a project. 

35.	Define XML – RPC? 
RPC stands for remote procedure class and is used to send request from one node to another on a network. Now, if we use XML to encode its call and send over HTTP is called as XML RPC.  
 
36.	What do you mean by PKI?
It means Public-Key Infrastructure. This infrastructure has got lot of entities to manage the public key encryption. 

37.	Can you name few free and commercial implementations for web services?
JAX_WS, apache axis, apache cfx, JAX-RX, restlet, resteasy, jersey and spring rest. Jeresy is a free implementation of rest web service. 

38.	How one can provide API to users? How can we create a web service and make it open for the world to use it. Like we have various app stores for publishing our apps. RRR
Once you have created your web service then you have a few options to make it public. You can host it yourself by buying a domain where you can deploy your web service. You can also deploy it on cloud service providers like Google Cloud, Amazon Web Services or Microsoft Azure. If you are not looking for server based deployment then you can probably deploy it to Google AppEngine or AWS Elastic BeanStalk which are more like app store for we service or application. For every option you will ultimately get a URL to access the deployed web service. This way it can be used by anyone who has access to internet. 
Now, you have deployed your web service but how would people know about it. Well, you need to do a little bit of publicity. You can probably have a blog or educational website for the web service you have created and play around with google search engine optimization technique to get hits from the users. You can also list your web service to some online API directories like ProgrammableWeb or Public APIs.
I think how google do publicity of their apps by dedicated web site which is developers.google.com.  
 
39.	How can you document web service? RRR
Well, for creating documentation for not just web service but for any kind of software, we have a lot of tools which are way too handy for this purpose. The best tool that you can use for documentation for your REST web service is swagger which is an open source tool. 

40.	What are distributed technologies?
Software which has different parts of it deployed on different servers. 

41.	Explain in brief, what DISCO is? RRR
DISCO means discovery. It groups the list of interrelated web services. The organization that provides web services, issues a DISCO file on its server and that file contains the links of all the provided web services. This standard is good when client knows the company already. Also it can be used within a local network as well. 
Note: it is only for soap web service. 
 
42.	What are the steps performed by the client to access a web service?
As far as rest web service is concerned. We just need to know the end point and the request method needs to be send. These details we must get from the web service provider. 

43.	Explain what is JAXP?
JAXP is a JAVA API for XML processing that enables application to write, read, manipulate and transform XML data.  Similarly, to perform other various function there are other Java API’s as well like JAX-RPC, JAXM, JAXR, JAXB, etc.
==================COMPLETE JAXB FIRST AND IF NEED IN FUTURE===========================
44.	Give a simple example of how XML document can be Marshal and Unmarshal in JAVA framework? Using JAXB for XML and Jackson for JSON. 
Marshalling is the process of converting XML document into Java readable form while UnMarshalling is the reverse process of Marshalling.  Let see how Java unmarshals an XML document and then marshals it back
JAXBContext jc= JAXBContext.newInstance (“com.acme.foo”);
// unmarshal from foo.xml
Unmarshaller u = jc.createUnmarshaller () ;
FooObject fooObj=
(FooObject)u.unmarshal (new File (“foo.xml”) );
// marshal to sytem.out
Marshaller m = jc.createMarshaller ();
m.marshal (fooObj, System.out);

56) Mention what are the types of validation can a JAXB client can perform?
There are two types of JAXB client validation that a JAXB can perform
    • Unmarshal Time Validation
    • On-Demand Validation
57) Mention what are the three ways to handle the event encountered during the marshal, unmarshal and validate operations?
    • Using the default event handler
    • Register and Implement a custom event handler
    • Use the ValidationEventCollector utility
58) Explain where does JAXB compiler is located?
JAXB schema binding compiler is placed in the <JWSDP_Home>/jaxb/bin directory.  In this directory, there are two scripts, xjc.sh (Solaris/Linux) and xjc.bat (Windows).
59) In what cases do you need to customize the default binding?
In some cases, you are required to customize the default binding like
    • Creating API documentation for the schema derived JAXB packages, classes, methods and constants
    • Giving semantically meaningful customized names for cases that the default XML name-to-Java identifier mapping cannot handle automatically
    • Overriding default binding- like specifying that a model group should be attached to a class rather than a list
60) Explain what is Inline Customization?
Customization to JAXB bindings made by means of inline binding declarations  in an XML schema file that take the form of <xsd:appinfo> elements embedded in schema <xsd:annotation>elements.
=====================================================================================

45.	Explain what is XML signature?
XML can be used to sign any arbitrary data whether it is a binary or XML. The purpose XML signing solves is what exactly a digital signing would solve but XML signing provides special feature of signing a section of a document and not necessary the entire document. 

46.	Explain what is Stax?
Stax stands for Streaming API for XML; it is an API to read and write XML documents, originating from the JAVA programming language.

Source 4: http://www.softwaretestinghelp.com/restful-web-services-interview-question/

47.	What are the core components of HTTP request and HTTP response?
The core components that come under HTTP Request are: Request Method, URI it wants to connect, Request header (info about the data, metadata), Request body (actual request data).
The core components that come under HTTP Response are: Response Code, Response header, Response body.

48.	Enlist advantages and disadvantages of ‘Statelessness’. RRR

In the above question, we have understood the meaning of statelessness with respect to the client-server communication. Now, let us see some of its advantages and disadvantages.

Advantages:
In increases the scalability by not having to manage the state. It makes the processing of the web service much simpler. 
Disadvantages:
In every HTTP request from the client, the availability of all the information regarding the client state is required by the web service.

49.	Enlist some important constraints for RESTful web services. RRR
Below are some constraints on restful web service:
1.	Uniform Interface: The URIs through which we expose the web service apis should be uniform. This means that the way URIs are build should look uniform.
2.	Client server coupling: This means that development of client and server should not impact each other. Only the client should depend on the URI not directly how api is build. This makes application and web service more maintainable. 
3.	Stateless: Should not store any previous request and hence no history. This leads to more scalability and simplification in the processing of web service. 
4.	Cacheable: These days caching is of at most importance as it can increase the performance.
5.	Layered System: A web service can have code on multiple server. 
6.	Code on demand: This is optional but if a client need code of an api then it can be given as response of the request. 
  
50.	What is a ‘Resource’?
Just like the ‘Object’ instance, we have learned in object orient programming Language, in the same way, ‘Resource’ is defined as an object of a type which can be an image, HTML file, text data, and any type of dynamic data. There are varieties of representation formats available in order to represent a resource. Every resource is mapped with a URI. 
Some most common are enlisted below:
JSON
YAML
XML
HTML

51.	Enlist some important points that should be kept in mind while designing Resources representation for RESTful web services.
Consider all the constraints of the roy fielding specification. Makes you rest api best.

52.	What is Caching? RRR

Caching is the process in which server response is stored so that a cached copy can be used when required and there is no need of generating the same response again. Only the client is able to cache the response and that too for a limited period of time. This boosts the performance of the web service by reducing the load of repetitive same requests.
GET method is kept cacheable by default while POST method is kept non cacheable by default. Under special situations, we can reverse the caching status for GET and POST. PUT and DELETE method cannot be made cacheable. 
Below are some http header which are important for controlling caching behavior:   
1.	Expire: The expire header specifies the absolute time of expiry of cached response. Beyond that time, a cached response is considered stale and need to be validated by the origin. 
2.	Cache-Control: this is explained in next question in detail. 
3.	ETag: Server identifies each representation with a unique number which is Etag. Etag changes as the state of the resource changes. 
4.	Last-Modified: Date header of response indicates when the response is generated while last modified header shows that when the resource was last modified.   
Mentioned below are the header of the resources and their brief description so that they can be identified for the caching process:
By the way, cache-control and Expire are two most important for controlling cache behavior. 

53.	Explain Cache-control header. RRR
A standard Cache control header can help in attaining cache ability. Enlisted below is the brief description of various cache control header directives:
Public: Resources that are marked as the public can be cached by any intermediate components between the client and server.
Private: Resources that are marked as private can only be cached by the client.
No cache: means that particular resource cannot be cached and thus the whole process is stopped.
max-age: this defines the seconds after which the cached copy should be considered stale.  

54.	What are the best practices that are to be followed while designing RESTful web services?
To design a secure RESTful web service, there are some best practices or say points that should be considered. These are explained as follows:
1.	Every input on the server should be validated.
2.	Never pass any sensitive data through URL.
3.	Only HTTP error messages should be used for indicating any fault.
4.	Use message format that is easily understood and is required by the client.
5.	All the constraints. 

55.	What is Payload?
The request data which is present in the body part of every HTTP message is referred as ‘Payload’.  In Restful web service, the payload can only be passed to the recipient through POST method.
There is no limit of sending data as payload through POST method but the only concern is that more data with consuming more time and bandwidth. This may consume much of user’s time also.

56.	Enlist some of the HTTP methods with description.
Mentioned below is the list of HTTP methods with their descriptions:
GET: This is a read only operation which fetches the list of users on the server.
PUT: This operation is used for the creation of any new resource on the server.
POST: This operation is used for updating an old resource or for creating a new resource.
DELETE: As the name suggests, this operation is used for deleting any resource on the server.
OPTIONS: This operation fetches the list of any supported options of resources that are available on the server.

Source 5:https://career.guru99.com/rest-api-interview/
15 Rest API Interview Question & Answers	
57.	Mention whether you can use GET request instead of PUT to create a resource?
No, you are not supposed to use POST.  GET operations should only have view rights

58.	Mention what is the difference between AJAX and REST? 
                                AJAX	                                REST
In Ajax, the request are sent to the server by using XMLHttpRequest objects. The response is used by the JavaScript code to dynamically alter the current page
Ajax is a set of technology; it is a technique of dynamically updating parts of UI without having to reload the page
Ajax eliminates the interaction between the customer and server asynchronously
REST requires the interaction between the customer and server
 REST have a URL structure and a request/response pattern the revolve around the use of resources
REST is a type of software architecture and a method for users to request data or information from servers
REST requires the interaction between the customer and server

59.	Mention what are the different application integration styles? 
The different integration styles include
Shared database
Batch file transfer
Invoking remote procedure (RPC)
Swapping asynchronous messages over a message oriented middle-ware (MOM)

60.	Mention what is the difference between PUT and POST?RRR
“PUT” puts a file or resource at a particular URI and exactly at that URI.  If there is already a file or resource at that URI, PUT changes that file or resource.  If there is no resource or file there, PUT makes one. POST sends data to a particular URI and expects the resource at that URI to deal with the request.  The web server at this point can decide what to do with the data in the context of specified resource
PUT is idempotent meaning, invoking it any number of times will not have an impact on resources. However, POST is not idempotent, meaning if you invoke POST multiple times it keeps creating more resources
PUT is to update a resource while POST is to create a resource.

source 6: http://www.java67.com/2015/09/top-10-restful-web-service-interview-questions-answers.html

RESTful Web Services Interview Questions 
Here is my list of RESTful web services questions for senior Java developers who have a couple of years of experience developing both SOAP and REST based web services. This is actually the second part of my series of Java web services based question, in the earlier article, I have shared some SOAP web services based questions. If you have not looked already, you may want to take a look. 

61.	What is WADL in RESTFul? RRR
Web Application Description Language stands for WADL. It is equivalent of WSDL of SOAP web service. Its too an XML document which describes a REST web service. It is very important to have a WADL of rest web service since it really helps use or integrate the rest web service.  
Very importantly, with jersey we can find the WADL with URL/application.wadl. Spring we need to configure a controller as described in the post here. https://dzone.com/articles/automatically-generating-wadl. 

62.	Can you do payload in HTTP DELETE?
Answer : This is again similar to previous REST interview question, answer is No. You can only pass payload using HTTP POST method.

63.	How much maximum pay load you could do in POST method?
Answer : If you remember difference between GET and POST request then you know that unlike GET which passes data on URL and thus limited by maximum URL length, POST has no such limit. So, theoretically you can pass unlimited data as payload to POST method but you need to take practical things into account e.g. sending POST with large payload will consume more bandwidth, take more time and present performance challenge to your server.

Source 7: http://javarevisited.blogspot.in/2012/01/rest-web-services-framework-interview.html

64.	What happens if RestFul resources are accessed by multiple clients? Do you need to make it thread-safe?
I think that we need to make our code thread safe and here is why. It is quite likely that a web service will receive multiple request at a given time then there are chances that those thread will try to use same resource in order to process the request and hence the chances of multithreading issue arises. 
Check this for more: https://stackoverflow.com/questions/16795303/must-spring-mvc-classes-be-thread-safe

Source 8: https://dzone.com/articles/rest-web-service-interview

65.	What is the difference between a RESTful web service (on HTTP) and a HTTP Servlet both of which perform the same function? RRR

REST is completely a architectural pattern while the HTTP servlet is an implementation. Now, RESTful webservices if speak about only in java can be like Servlet. We can create a webservice using jeresy framework which itself is built on top of servlets. However, Restful webservice is a vast topic. 

66.	How will you migrate from SOAP web service to RESTful web service? RRR
There can be multiple ways of converting the SOAP web service to REST web service. 
a.	Create a new REST web service from scratch and utilize the code, sql query and anything if at all of SOAP web service. 
b.	To build a proxy or a adapter class which takes the request from client, convert it as SAOP likes it, receives SOAP response, convert it to JSON or any other format needed. Then, send the final response to the client. Certain level of performance hit as this process would definitely will take longer than usual time in every call.  
c.	There are certain tools that can make the work very easy like Apigee Edge which is a part of google cloud and many other. All they need in the link of the WSDL and you get a REST api.
Depending on various factors like time, cost, man power and other, we can decide which of the above method is best. 

67.	Can my web browser be a client to RESTful web service? If yes then how will you generate DELETE request from web browser? RRR

Through web browser we can send GET and POST request. GET request by simply putting the url and hit it. POST request by filling and submitting a form. 
For PUT and DELETE, we can do AJAX call from the browser though. But, we cannot do synchronous PUT or DELETE action to a web service through web browser. 
Lastly, we can install any useful plugin like PostMan for PUT and DELETE but alone browser is insufficient. 

68.	 How will you handle synchronization issues when multiple clients try to consume web service simultaneously? Check the scenario in the answer. RRR
We need to handle synchronization issues in the same way in web service as we would do in any web application. This is because when a web service get concurrent requests at a time then each request is handled by a thread in the same process. Then, there are chances when multiple thread would want to work on a same object at a time. Thus, we need to take care of multi threading issues here too. 
One good scenarios is there is a list of object of about 25000 entries. There are multiple threads which will possibly be reading from this list and in every 30 mints this list updates from db. The update takes a few milliseconds. How to deal with possible multithreading inconsistency issues?
We can definitely put an explicit synchronization through synchronized keyword or lock interface. Doing that the thread that wants to update will wait until the currently reading thread is done. Then it acquires the lock and updates the thread. Once update thread is done then it releases the lock and threads can read from it. But this will bring synchronization overhead. Do we have a simpler option?
Evaluate all options suggested https://stackoverflow.com/questions/30045803/java-synchronization-in-web-service

69.	Can you describe any one RESTful web service you have written? RRR
Put Ranjana’s project detail and RealQuest consumer detail. Try and get detail of other rest webservice. 


70.	What will you do when an error code has to be returned to the client? RRR
Important link: http://archive.oreilly.com/pub/post/restful_error_handling.html
According to the above link, we can handle the error in web services by four ways. 
1) stick to standard HTTP errors, 
2) give blank xml set, 
3) pass extra information in response headers as X-DAS-status: 403 for example while giving standard HTTP error. For this, we need to check the resposne header explicitly. 
4) we can send an xml document with the error message. last option seems of be the best one. 

Note:
In spring Rest, we can handle the exceptions gracefully through annotations which are @ExceptionHandler, @ResponseStatus, @ControllerAdvice and other. 
Let’s understand this through a situation. Assume, the client sends a request to get the details of an employee with id X and there isn’t any employee with id X. In this scenario, employee object will be returned but with no data set to its data members. Let see what code changes can be code to handle this gracefully. 
In the controller, we can place a condition to throw a custom exception in case if employee is not found for the input id. So, now we need to create that custom exception EmployeeNotFound.java. We can create it like any other custom exception in java but we need to use annotation on the class level @ResponseStatus(value=HTTPStatus.NOT_FOUND, reason=”Employee does not exist”). 
While using this in controller we simply need to just throw it like any normal custom exception and use throws keywords as well in method signature. 
After doing the above code changes, the standard NOT FOUND 404 http error page will be shown as the response with reason that we mentioned in the annotation. But, if we need to give out own custom error page as response then we need to write handler of the custom exception that we created. So, we can create a method in controller class as HandleCutomException and return a modelViewObject setting the values that we want to show on the page. We need to use annotation @ExceptionHandler(EmployeeNotFound.java). This way whenever this exception comes then we can the modelAndView that we are returning through the handler will be sent in response. Also, the response status will be 200 since we are sending the view our self after processing.
Now, since exception can come in any controller of application thus it is important to have a dedicated handler class which has handler method of each exception (custom or primitive exception). In the dedicated class, we have to use annotation @ControllerAdvice to mark the class as handler exception is applicable for all the controller classes.   
For everything: https://www.journaldev.com/2651/spring-mvc-exception-handling-controlleradvice-exceptionhandler-handlerexceptionresolver. 
RRR: check how exception is handled in FAS.

71.	Is it mandatory to use HTTP protocol for performing CRUD operations by a REST based web service? 
Actually, I never heard of using any other protocol for performing CRUD or even anything else except HTTP methods like GET< PUT< POST and DELETE for rest web service. 


72.	Can one RESTful web service be a client to another RESTful web service for performing business operations? Describe with example? 
Yes. For sure. In fact, not necessarily to be a RESTful. For example, you may have an API which aggregates the data from Twitter and instagram. This you provide to the user of your API.
Also, provide FAS and CDM example.

73.	Can you generate HTML output from a RESTful web service? How?
Yes. We can mention @produces(MediaType.APPLICATION_HTML). 

74.	Can a RESTful web service generate output in various formats based on some parameter received from the client?
Yes. In request header, we should receive accept as some particular type. This instruct the output type. In fact, I guess we can send multiple options in accept header and even set the priority. In case, if web service is unable to send the data in the asked type then it says unsupported media type 415.

75.	With a RESTful web service, whose state is getting transferred and how?
State of application (service) gets transferred through the request and response we see. 

76.	Who owns the specification for REST web services and how does it get updated to newer versions? 
Not really sure, but i think this is managed by W3c. World wide web consortium. 

Few more website to follow:
Source 9: https://javarevisited.blogspot.com/2018/02/top-20-spring-rest-interview-questions-answers-java.html
77.	What are safe operations in REST?
Safe operations are those in which do not modify the resource of the server. Rest uses HTTP only and its method. GET and HEAD are safe method making no change on the server resources while PUT, POST and DELETE are not safe operation.
 
78.	What is RestTemplate class and what is its advantage?
RestTemplate is a class which is a part of Spring Rest framework. This class is used to create REST clients. It has methods like getForPost(), exchange, postForObject() and other.

79.	What is HttpMessageConverter and what is its advantage? RRR
HttpMessageConverter is an interface in Spring Rest framework which is used to convert format (JSON, XML etc) before or/and after the http request. We are given default message converters in spring rest while we can create customMessageConverters as well and can use them in controllers. For creating customMessageConverters we need to create a new implementation of AbstractHttpMessageConverter. 

80.	 Are @controller and @RestController stereotypes?
Yes. Both are stereotype. @Controller is a specialized version of @Component which means that a class is just not a component but a controller component. @RestController is specialized version of @Controller servers a combo of @Controller and @ResponseBody. @RestController indicates that a class its used with is a controller which handles RESTFul request. 

81.	What status does delete request gives? RRR
There is no standard as such. If an empty body response is sent back to client then the status will be 204 which is no content. While if some content is send back after delete request then the response status will be 200. 

82.	What does CRUD operations mean and how to be achieve in REST api?
CRUD stand for Create, Read, Update and Delete. In Rest, HTTP request methods are used to perform these operations. GET is used for read, POST is used to create, PUT is used to update and DELETE is used to delete. 

83.	Would you need Spring MVC in your classpath for developing RestFul Web service?
Yes. I will need spring MVC jar on my class path as it provide crucial annotations like @RestController. @ResponseBody, @ResponseCode, @RequestBody, @PathVariable and other. 

Source 10: https://www.softwaretestinghelp.com/restful-web-services-interview-question/
84.	What is addressing with respect to rest web service?
It is nothing by exposing all your resources of web service using URLs. 




Special Questions:

1.	If rest web service does not have WSDL then how can we get to know about the API to consume the web service? Also, what method of web service to use for what function and how?
Rest web service is all about resources which are nothing but the urls through which the functionality of a web service is exposed. Since, there is no WSDL in rest web services, the responsibility lies with the web service provider to make its endpoints (resources) public. One good example is when we try to use google maps api then we need to go to googles website and look for endpoint. Also, if we wanna use any api of a rest webservice then again service provider has to make details of api public somehow. This is generally done these days by web service provider on their website or some platform. 

2.	Why a Rest web service should always be stateless? RRR
Rest architecture says that a Rest web service should always be stateless which means the session state must entirely be handled on the client side. We must not get confused about the web service of being stateless mean that state in not maintains while dealing with web service. It has to be maintained but entirely on the application communicating with the web service which is client side.
Now, to understand why rest web service must not be stateful, we need to understand what disadvantage we get if we try to manage state on webservice (server side). We are putting load on web service to manage the session for may be millions of client consuming it. Thus, this impacts the scalability. Therefore, to improvement the scalability the session management is done on client (consumer side).  
Note: By the way, in web application developer it is common practice to manage session on server side. It is considered good practice as it gives a central point to manage the session (in multi server app, client has to send session data to each server), session will be immediately created (need not to wait for cookie send by browser), user details are not exposed (else you provide a very strong encryption when client sent data to session), cookie size is smaller. 

3.	What is the advantages of using XML or JSON in web service? RRR
The two most generally used types of data used to communicate between client and web service is XML and JSON. Let’s check out the advantage of both.
a.	JSON is lighter or compact than XML
b.	JSON can be loaded faster than XML in javascript which is the most popular client side scripting language.
c.	XML has schema support while JSON does not have. XML schema support i.e. XSD governs the structure or the format of an XML document. XSD is also an XML document so we do not need to learn anything new to create or understand it. With respect to web services, it helps in building the request or response as needed. 
d.	XML has namespace support while JSON does not have. Namespace is quite helpful in avoiding the name conflict. We give prefixes to avoid conflicts. It can be savior while mixing two XML document and to be protected from the same name tags. Check example: https://www.w3schools.com/xml/xml_namespaces.asp
e.	Check the differences on parsing of XML and JSON.

4.	What is web service protocol stack? RRR
Web service protocol stack is protocol to define, locate, implement and make one web service to interact with other. Web service protocol stack has generally four protocols which are below:
a.	(Service) Transport Protocol: It is responsible for transporting message from network application to web service and the other way too. It includes protocols such as HTTP, FTP, SMTP etc. 
b.	(XML) Messaging Protocol: responsible for encoding message into a common format to be understood by application and web service. It includes XML, JSON, HTML, Text etc. 
c.	(Service) Description Protocol: used for describing public interface to web services. It includes WSDL.
d.	(Service) Discovery Protocol: used to discover the web service from a centralized registry. It includes UDDI. 

5.	How to manage security in REST web services? What are the aspect that we need to manage? Check how to do it in Spring rest and if possible spring security? RRR
Security is a critical aspect of a web service and which is not an afterthought. It needs to be planned right from the development phase begins. The important aspect of security is authentication, authorization, encryption and other. 
Before we go in details, let’s clarify the difference in authentication and authorization. Authentication is the process to validating the user identity. This is generally done though login id and password. Once the user is authenticated as it claims, we need to check if the user has authorization of the resource that it is requesting. The process of checking if any specified user has access for a requested resource is what authorization is. 
Let’s start with understanding different authentication techniques:
a.	BASIC Authentication
With Basic authentication, client sends its base64 encoded username and password with each request as authorization header of request. The value of authorization header comes in the format “Basic+base64ClientCredentials”.  
Since, the credentials are passed from client to server with just base64 encoding (with not encryption) thus is not really that secure. It can easy task for a hacker to sniff credential from basic authentication. Therefore, it is highly advicable to use it with HTTPS rather than HTTP. 
Now, let’s see how can be configure basic authentication with spring rest web service:
1.	The very first thing is to get spring security dependencies added in POM.xml. We will mostly will need spring-security-web and spring-security-config. 
2.	We have to create securityConfiguration class which will extend WebSecurityConfigurerAdapter class of spring security config property. The important method here is configureGlobalSecurity(AuthenticationManagerBuilder auth) to set the user with their password and roles. There are other method which are obviously very difficult to remember for now. @enableWebSecurity is the annotation that we will be using with this class. 
Once this configuration is done then we can use the basic authentication. In case, no or wrong creds are send in request header then 401 (bad credentials) will be returned as response. 
Also, I guess for more clarity on implementation we can try hand on to it. 

b.	DIGEST Authentication
This authentication uses hashing algorithms to encrypt the password before sending it to server. This obviously makes security stronger than basic authentication technique by encrypting the password. The commonly used hashing algorithms for hashing are MD5, SHA etc.
Also, we need to understand that once the password is converted to hash then it cannot be converted to password. So, when we need to authenticate the user then we need to authenticate with hash of what is sent to the hashcode of the password stored. 

c.	Client CERT Authentication
In this authentication technique, client shows a certificate to server in each request to authenticate instead of password. The certificate must be signed by an agency which will ensure that the certificate presented to authentication is legitimate. These agencies are known as CA. The certificate actually contains user details and private public key pair. 
This authentication must only be used with HTTPS otherwise there are chances that the clients identity may get stolen.
 
d.	OAuth 2
OAuth stand for Open Authorization (not for open authentication) protocol or framework which describes how unrelated servers or services can safely allows authenticated access to their resources without actually sharing initial or logon credentials. 
One good example, when you try to log on to OLX then it gives options to log in with facebook or other website. The advantage if I am already logged on facebook then I do not need to authenticate myself for OLX. Thus, authentication of facebook provides authorization to use OLX and thus this protocol is Open Authorization but not Open Authentication. Also, facebook does not share the creds with OLX in this case.
OAuth can only be implemented using HTTPS. For an application, adopting Oauth for authenticating a user would need to use API of commonly used social media platform like facebook which can authenticate a use for them. 
OAuth 2 is nothing but second version of OAuth framework. OAuth2 was quite criticized for the differences it has over OAuth1. OAuth2 seemed to be more focused towards interoperability and thus lacks of security aspect. OAuth2 is not backward compatible because of major differences with OAuth1. 
Good Read on OAuth: https://www.csoonline.com/article/3216404/authentication/what-is-oauth-how-the-open-authorization-framework-works.html

6.	Try and describe about using swagger with your spring rest application for documentation. 
For any web service, it is very important to have its API documentation done properly. Doing it manually could be very tedious and thus we must look for automated ways. Swagger specification is created for serving as a guidelines defines the files needed to describe an API. There are many implementations of swagger specification. SpringFox is one such implementation of swagger 2 specification. 
With Spring Rest web service, we can quite easily plug in swagger implementation. We have first mention the dependency in POM.xml.  We will need to do some configuration as well. We need to first write SwaggerConfig.java class which returns the Docket. We have to use @EnableSwagger2 annotation for enabling the springFox. In the absence of spring boot, we manually have to write another api in the same config class. addResourceHandler() to add the resource handlers location which is primarily needed for swagger UI. 
We can test if its working on not using link: https://mywebservice.com/context-root/api/v2/api-docs. 
Although, the file at this path is not so human readable. Thus, we want swagger UI. We need to add its dependency. Then, through the URI, https://mywebservice.com/context-root/swagger-ui.html  
There are many other advance configuration for more documentation features. 

7.	Try and describe about how would you implement caching in rest web service?
Spring provides abstraction layer for plugging in any cache implementation with it. There are many popular cache implementation available which are JDK (concurrentMap) based cache, EhCache, Guava cache and other. In the example, we will be implementing cache using Ehcache implementation. 
Now, let check out how can we plug in Ehcache to our spring application or REST web service. We obviously need to have dependency of Ehcache jar in POM.xml file. We need to have below dependency:
	<dependency>
	    <groupId>org.springframework</groupId>
	    <artifactId>spring-context-support</artifactId>
	    <version>4.1.4.RELEASE</version>
	</dependency>	  	

This will give all the necessary classes which will be needed to support caching. This dependency will not only get classes for Ehcache support but for other caches file Guava, jcache and other. 
Once we have all the needed spring support classes for Ehcache then we can configure the Ehcache beans in application-context.xml. Below is the code for same:
<bean id="ehcache" class="org.springframework.cache.ehcache.EhCacheManagerFactoryBean" p:configLocation="classpath:EhCache.xml" p:shared="true"/>
	  
<bean id="cacheManager" class="org.springframework.cache.ehcache.EhCacheCacheManager" p:cacheManager-ref="ehcache"/>
If you noticed we have created bean for EhCacheManagerFactoryBean class and set the configlocation to EhCache.xml file. In the second bean, we have created bean for EhCacheCacheManager. 
We can also configure Ehcache on annotation basis simply like: “<cache: annotation-driven>”. 
Now, we will create the Ehcache.xml which will have all the configurations needed for EhCache. Below is a sample code: 
<ehcache>
	 <defaultCache
		 maxEntriesLocalHeap="10000"
		 eternal="false"
		 timeToIdleSeconds="120"
		 timeToLiveSeconds="120"
		 maxEntriesLocalDisk="100000"
		 diskExpiryThreadIntervalSeconds="120"
		 memoryStoreEvictionPolicy="LRU">
		 <persistence strategy="localTempSwap"/>
	 </defaultCache>
	 <cache name="customer" 
	 		maxElementsInMemory="10000" 
	 		eternal="false" 
	 		timeToLiveSeconds="3600" 
	 		diskPersistent="false" 
	 		memoryStoreEvictionPolicy="LRU" 
	 		overflowToDisk="false" />
</ehcache>
<defaultCache> specify some cache properties while <cache> tag with name attribute sets properties for a specified cache. There can many such caches. 
Now, in the controller classes, we can use below annotation for different purposes. 
1.	Cacheable: This makes a particular controller method cacheable. It can be used like “@Cacheable(value=“customer”)” on the method signature. 
2.	CachePut; This annotation is used to update the cache. The method will always execute and the cache will be updated each time. I guess it is intentionally be placed on any method to update the cache. 
3.	@CacheEvict: This annotation is used to remove the cache from the memory. This is placed in the special method called only to evict the cache from memory. We can use allEntries=true fro evicting all the cache.  

8.	HATEOAS concept needs to be checked. 
HATEOAS stands for Hypermedia as the Engine of Application State is one of the feature of RESTful architecture which makes it different from other network application architecture. Here, hypermedia term refers to any content that contains a link to other content. With HATEOAS, we can use links in the response of REST web service so that the client can navigate to the other content as well if needed. This is conceptually same as hyperlink in a web application. 
Now, to add the HATEOAS in rest web service, below are the steps:
1.	Add the HATEOAS dependency in POM.xml
<!-- https://mvnrepository.com/artifact/org.springframework.hateoas/spring-hateoas -->
<dependency>
    <groupId>org.springframework.hateoas</groupId>
    <artifactId>spring-hateoas</artifactId>
    <version>0.25.0.RELEASE</version>
</dependency>
2.	We need to create a class (may be inner class inside controller) where we will mention the field which are needed along with the link. We will create getters and setters like any other class. Then, extend ResourceSupport which is a part of spring HATEOAS. This class has add method which allows us to add the link to the returned object. It does have id property and thus when you try to have id property in sub class then it gives error. So, mind having id property in lower class.
3.	Then, in the controller class, we will create an api which returns the object or list of object which extends the ResourceSupport class. We need to create a Link object. Link class is again a part of HATEOAS jar. We need to use toLink() api of HATEOAS ControllerLinkBuilder class. Other important method are slash() and withSelfRel(). Slash() method is used to provide slash in the URL while WithSelfRel() method actually created a link with self relation by default. Once you have the link created then use add method to add the link to the class object which extends the ResourceSupport class. 
Although, this topic has lot of topic but it’s enough to begin. Later, let’s try to create an example.  


9.	What are the best practices to name a resource or to create its URI?
Uniform URI is one of the constraints or guideline for a good rest web service. Every data representation is a resource in web service. A resource can be a collection resource or singleton. Like, customers is a collection resource and customer is a singleton resource. To get the list of customers we can have URI as /customers and to get a certain customer out of all the customer is “/customers/{customer}”. A customer can have multiple accounts and to get those account URI should be “/customers/{customer}/accounts” and to get one of the account of that customer the URI should be like “/customers/{customer}/accounts/{account}”. This shows it’s always good to build the URI following the tree.
Below are some tips in building good URI:
1.	Do not use the trailing / in the URI
2.	Use hyphen instead of underscore. 
3.	Use lowercase letters in URI
4.	Do not use file extension
5.	Never use CRUD functions name in URI since your http method will make it clear. 
Like, GET request: /customers/{customer} will get you a customer
POST request: /customers/{customer} will post a customer. 


10.	Check Idempotence with respect to REST api.  https://restfulapi.net/rest-architectural-constraints/
Any API that returns the same result irrespective of how many times its called then its called idempotent. No matter if you have called an idempotent method the first time or tenth time, It will produce the same result. If we follow all the guidelines of REST architecture, then except POST API, every other method will be idempotent. 
Even in HTTP protocol, except POST method, other methods like GET, PUT and DELETE are idempotent methods. 
POST is not idempotent because a new resource will be created on the server every time you call it. 

11.	What are your thoughts on response compression?
The primary advantage of compressing the response to save some bandwidth with a slight cost of adding some complexity. We can manage compression of response through request and response headers. Below two headers are mostly used for the purpose:
1.	Accept-Encoding: It denotes what type of compression does the client accept and is capable of decompressing and get the original response. While a client sends a request to server, it can mention the accept-encoding header. If it mentions anything that server is not able to perform compression in then 415 HTTP error will be sent. Frequently used values for accept-encode header is gzip or compress. 
2.	Content_Encoding: When server finds that the compression type asked by the client is fine with server then server can tell client the encoding type it has used through response header content-Encoding. This is especially good when client has mentioned multiple compression type in request. A similar header is transfer-encoding. It is used when each segment of multi-node connection can use different encoding. 

12.	What is content negotiation? How can we control it? RRR
A resource can be represented in different presentation. This is because a web service generally has variety of client which can ask for different presentations. Asking for a suitable presentation of a resource by the client is known as content negotiation. 
Content negotiation can be server driven or client driven. Server driven is generally avoided as its very hard to predict which type of presentation would be needed the client and that would unnecessarily add complexity on server. The best approach is when client specifies itself what presentation it needs.
Below are the ways in which client can tell server about the content type in which it needs a resource:
1.	Through HTTP headers: client can specify in the request header with header accept about the content it needs resource in. With header, content-type, server gets to know about the data type used by the client. 
2.	Through request URL: client can also specify the content type needed through request URL. For example, http://mywebservice.com/resources/resource.json. This example URL shows that client needs resource in JSON.
3.	Defining Preference: It is possible to have multiple values in accept header. It can give preference among the options. For example, “accept=”application/json, application/xml; q=0.9,*/* q-0.8””. This accept header says that the client needs JSON, if not available then XML and if both are not available then anything. Q variable shows priority. If q is not specified then it understood as 1. 

13.	Check all possible annotations can be used in Spring REST web service. RRR

a.	@RestController: This annotation can be understood to have same effect as the combination of @Controller and @ResponseBody. This mean that since we are specially saying that we want a controller of rest web service thus we would mostly want to return the response as object of resource. In case of @RestController, we do not need to use @ResponseBody with method signature but its given automatically unlike in the case of @Controller. 

b.	@RequestMapping: Request mapping annotation is used primarily to map the controller method with a URI. However, it has other many attributes to specify different behavior of that method. Below are the attributes commonly used with @RequestMapping:
1.	Value = “/URL”
2.	Method = RequestMethod.GET (Likewise, POST, PUT and DELETE)
3.	Produces = MediaType.APPLICATION_XML_VALUE (likewise, for other media type)
4.	Consumes = MediaType.APPLICATION_XML_VALUE (likewise, for other media type)
5.	Header = {“header-attribute = attribute value”}
RequestMapping also takes multiple URIs at a time. For example, @RequestMapping(value={“”, “/first”, 
“*/second”}. Also, it supports wild cards in the URI. 
RequestMapping also takes variable path like value=”/someConstant/{Variable}”.

c.	@ResponseBody: As the name says, this annotation says that whatever the method returns will be serialized to become the response body directly. The format in which it is convert and then becomes the part of response body depends on the message converted (Jackson, JAXB or other), produces attribute of requestMapping and accepts header attribute of request. When nothing is specified than I guess JSON is sent by default provided you have Jackson. 
Also, we are not required to use @ResponseBody separately when using @RestController annotation as it is given by default with it. 

d.	@RequestBody: This annotation is opposite of @ResponseBody. It is used to get whatever given in the request body into a java object after deserialization. Like, for creating an employee on the server, you need an employee object. Thus, the JSON version of the employee is given in the request body. The body is directly consumed by the employee object which is an argument of create employee method with the help of this annotation. 
Method Signature: public @ResponseBody String createEmployee(@RequestBody Employee emp){ 
We can manage the data format that needs to be sent with the request through content-type header on client side and consumes attribute of RequestMapping on server side. 
If data sent as request body is different from either the content type or comsumes attribute then 406 comes as unacceptable.   

e.	@PathVariable: Path variables annotation enables us to use any variable in the URI of controller method. The classic example is to get the employee id. For a URL like http://localhost:8080/employeepro/employee/1 and mapping like “value=/employee/{id}”. Now, to use the id provided in the request as path variable, we need @PathVariable annotation. 
We may also have multiple vairables in the URI and we can use them like below:
URI: value="getthatemp/{id}/{accountid}" RRR
Method: public Employee getThatEmployee(@PathVariable(value=”id”) int id, @PathVariable(value=”accountid”) int accountId){}

f.	@RequestParam: Request param annoatation lets the web service method to use the request param. In a URI, the key value param mentioned after the ? symbol are request param. Like, http://localhost:8080/employeepro/deleteemp?id=1 and mapping like “value=”/delete”” will take the request param and can use them for processing with method signature like “public String deleteEmployee(@RequestParam (value=”id”) int id){}”
Like, @pathVariable annotation, we can use multiple @RequestParam annotations in a method. 

g.	@QueryParam: Firstly, QueryParam is not of Spring framework annotation, but belong to JAX-RX framework. The major different between them is that @ReuestParam will always need a value or bind and if not provided then it gives error while @QueryParam would not mandatorily need a value. We can manage the same though in @RequestParam by mentioning another attribute required=false. 

h.	@PathParam: Like queryParam, this annotation too only belongs to JAX-RX and not to spring. However, serves the same purpose. 

i.	@XmlRootContext: This annotation is used to specify the root element in the bean class so the JAXB can convert XML to java object and vice versa. 

j.	@XmlElement: This annotation is used to specify a variable in bean class as element of XML document. 

k.	@XmlAccessorType: This annotation is used to control whether the serialization and de-serialization. By default its value is PUBLIC. 

l.	@XmlType: can give name, order of the properties. Can get more understanding with more knowledge of XML document. 

m.	@JsonSerialize: This is not a mandatory annotation. It can be used on class level, on variable declaration or on its getter method. Its primarily to control the serialization behavior of the variable. 

n.	@ResponseStatus: This annotation is used with the custom exception class. The important variables for this annotation are below: 
RRRValue=HttpStatus.NOT_FOUND
Reason=”The employee with the detail given is not found.”

o.	@ExceptionHandler: This annotation is used with a method that implements the handler of any custom or primitive exception. 

p.	@ControllerAdvice: This annotation is used with the class that has got the handlers of all the exception. 

q.	@EnableWebMvc: This annotation is used to configure Web MVC of spring using annotation. It is equivalent of <mvc: annotation-driven> in XML configuation.
Note: 
We can get data from @PathVariable and @RequestParam both, but any mandatory data for the processing of response need to come in @PathVariable while anything that is optional may come in @RequestParam. This is just a good to follow thing. 

14.	Mention all the configuration step by step for creating a basic REST web service. RRR
Here, we have step by step configuration to have a simple Spring REST web service using all HTTP request method generally used which are GET, PUT, POST, DELETE.
Step 1: Create a simple java maven project with webapp archetype. Do not know why I got two source folders missing. I created them manually. 
Step 2:  Write project dependencies in POM. We can check the spring REST jar dependency on maven site. You will find something like below:
<!-- https://mvnrepository.com/artifact/org.springframework.data/spring-data-rest-webmvc -->
<dependency>
    <groupId>org.springframework.data</groupId>
    <artifactId>spring-data-rest-webmvc</artifactId>
    <version>3.1.0.RELEASE</version>
</dependency>
Mention the above dependency under dependency tag in POM. We need to mention other dependencies like Jackson and JaxB. 
Also, the other way around is to manually import these jars if you have already downloaded them. 
Step 3: Write servlet mapping of dispatcher servlet in web.xml. 
<!-- The definition of the Root Spring Container shared by all Servlets and Filters -->
	<context-param>
		<param-name>contextConfigLocation</param-name>
		<param-value>/WEB-INF/spring/root-context.xml</param-value>
	</context-param>
	
	<!-- Creates the Spring Container shared by all Servlets and Filters -->
	<listener>
		<listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
	</listener>

	<!-- Processes application requests -->
	<servlet>
		<servlet-name>appServlet</servlet-name>
		<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
		<init-param>
			<param-name>contextConfigLocation</param-name>
			<param-value>/WEB-INF/spring/appservlet/servlet-context.xml</param-value>
		</init-param>
		<load-on-startup>1</load-on-startup>
	</servlet>
		
	<servlet-mapping>
		<servlet-name>appServlet</servlet-name>
		<url-pattern>/</url-pattern>
	</servlet-mapping>

Step 4: Create the root-context.xml mentioned in context param and servlet-context.xml mentioned in init param in the specified location. 
In root-context.xml, we have not wrote generally anything and it is not even mandatory to mention. 
In servlet-context.xml, we have many thing to me noted. Lets check them one by one:
1.	Annotation driven tag
<!-- Enables the Spring MVC @Controller programming model -->
	<annotation-driven />

2.	View resolver tag
<!-- Resolves views selected for rendering by @Controllers to .jsp resources in the /WEB-INF/views directory -->
	<beans:bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
		<beans:property name="prefix" value="/WEB-INF/views/" />
		<beans:property name="suffix" value=".jsp" />
	</beans:bean>

3.	Component scan: like what packages to scan for controllers. 
<context:component-scan base-package="com.mycompany.controller" />

Step 5: Create a bean class. Like, for employeepro app, we have created a bean class which is employeeBean. 
We need to use annotation @XmlRootElement for specifying the root element of the xml. For JSON, we do not need to specify any in particular. For any controller method, if we need to send any response like user defined object then we need to have root element mentioned in the class.  
If our bean class have any user defined type variable then we need to create its class like any other bean class and need to specify the xml root element. Address in employee is the user defined class thus have a look at it. 
Step 6: Create a controller class inside the package mentioned for component scan. 
We need to write multiple controller method for different purposes. Like, for getting all the employees we can write method getAllEmployees. The basic annotations that we use are 
@RequestMapping(value="/getallemps", method= RequestMethod.GET, produces={MediaType.APPLICATION_JSON_VALUE, MediaType.APPLICATION_XML_VALUE})
	public @ResponseBody EmployeeList getAllEmployees(){
		EmployeeList allEmployees = new EmployeeList();
		List<Employee> allTheEmployee = new ArrayList<Employee>();
		
		Employee employee1 = new Employee();
		employee1.setId(1);
		employee1.setName("Rishav");
		employee1.setCreatedDate(new Date("22/04/1992"));
		
		Employee employee2 = new Employee();
		employee2.setId(1);
		employee2.setName("Rishav");
		employee2.setCreatedDate(new Date("22/04/1991"));
		
		allTheEmployee.add(employee1);
		allTheEmployee.add(employee2);
		allEmployees.setEmployees(allTheEmployee);
		return allEmployees;
	}
We can have both XML and JSON in produces. So, whatever accept header value will contain (JSON or XML), that media type will be used. This is a good technique to cover clients that will need to different media type for the same content. If nothing is specified in accept header then JSON content will be send. 
We can mention TEXT_HTML_VALUE and return a string with @responseBody annotation to simply return HTML content. 
@ReponseBody annotation is used to directly send the return value in the specified media type. If we do not use this annotation then we might need to send the response as a view. While creating rest web service we will need it almost everywhere. We will discuss other annotations separately. 

15.	How do we implement logger in a web service? Use the log4j.
I have used logger log4j. We have to give its dependency in POM.xml i.e. it has to be on our class path. 
I have created a class called Mylogger in common package. There I will created Logger class of log4j instance and initialized it in constructor. Then, we need to use the BasicConfigurator.configure(MyLogger.class). Instead of .class argument we can give a string as well. Then, we need to simply use the instance we have created in this class in any other class we need to do the logging.
In general, what I have seen is the same I.e to have a customer logger extended log4j in common and used everywhere in the class.  
Check with Ranjana, how logging is done in their project. Check how your project is doing logging too.

16.	Explore the scenarios where we need to parse XML and JSON content. Especially in web service creation. How do we do XML and JSON data parsing? Try and describe using JAXP and JAXB with REST web service. Also, when do we do marshalling and unmarshalling manually? Like, when we do not use annotations?
With annotations like @RequestBody and @ResponseBody, whatever xml or json content given directly gets de-serialized and given to java object and vice versa. I guess in the absence of such annotation we would need to parse and map the data to java object manually. In fact, thats when to use marshaller’s marshal and unmarshal methods to manually do the process. 
Good Link to manually work with Jackson: https://www.journaldev.com/2324/jackson-json-java-parser-api-example-tutorial

17.	What is HttpEntity, RequestEntity and ResponseEntity?
HttpEntity is a spring framework class which is created to represent entities of http request or response. These entities could be header or body. This is generally used with RestTemplate class of spring. Suppose we need to send custom http header of request or response then we can create a HTTP header object, set the header attributes that we want and add that newly created header as an entity in HttpEntity class object. We can also add httpBody object as entity in HttpEntity object. HttpEntity class is a generic type class and thus we need to define the data type of the entity while creating its object. 
RequestEntity is also a spring framework class and an extension of HttpEntity class. It adds method type and uri field other than what it gets from HttpEntity. 
ResponseEntity is also a spring framework and as extension of HttpEntity class. It adds status code other than what it gets from HttpEntity. 

18.	How do we send http request and get response in simple java JDK classes without any framework? Compare the classes that we have for sending requests in spring framework with simple java jdk classes. RRR
Let’s look at the most naivest way of sending an HTTP GET and POST request using classes given in java JDK. Source: https://www.mkyong.com/java/how-to-send-http-request-getpost-in-java/
Step 1: Create a String URL like below:
String url = http://localhost:8080/someendpoint;

Step 2: Create connection object using HttpUrlConnection class. This class has various APIs for setting up a connection and controlling request and response stuff. We can create its object using URL class openConnection() api like below:
URL obj = new URL(url);
HttpUrlConnection con = (HttpUrlConnection) obj.openConnection();

Step 3: Now, the connection is created with the target URL. We need to set the request type method bu setRequestMethod() that we want use which is GET by default. We can also set header properties using api setRequestProperties().
Con.setRequestMethod(“GET”);
Con.setRequstProperty(“HeaderAttributeName”, “HeaderAttributeValue”);

Step 4: We will not check the response code and if the response code is 200 which is OK then we will capture the response. Here, the key apis are getResponseCode(), getReponseMessage() and getInputStream().
Int responseCode = con.getResponseCode();
If(responseCode==200){
	bufferedReader br = new  BufferedReader(new InputStreamReader(con.getInputStream));
	String inputLine = “”;
	StringBuffer response = new StringBuffer();
	while((inputLine = br.readLine())!=null){
		response.append(inputLine);
}
br.close();
}else{
	System.out.println(“Get request did not work”);
}
Note: for post request, we need to add request params as well. Thus, we need to create DataOutputStream object and writeByte to the output stream. Below is the code:
// Send post request
		con.setDoOutput(true);
		DataOutputStream wr = new DataOutputStream(con.getOutputStream());
		wr.writeBytes(urlParameters);
		wr.flush();
		wr.close();

 
Now, there are many other frameworks which gives different classes for sending an HTTP request. Like, apache gives HttpClient for connecting to a server, sending request and capturing response. Lastly, except few situation, we might want to use HTTPClient over HttpUrlConnection because of speed and improved features. 
Now, since we have worked on creating web services using Spring Rest thus we should also know how to create client using classes provided by spring rest. 
In spring rest, we are given RestTemplate class which has got lot of APIs which can be used to create rest web service client.
Case 1: for getting employee as XML response:
private static void getEmployees()
{
   final String uri = "http://localhost:8080/springrestexample/employees.xml";   
    RestTemplate restTemplate = new RestTemplate();
    String result = restTemplate.getForObject(uri, String.class);
    System.out.println(result);
} 
In the above code, we are creating a URI string first where we have mentioned the extension XML at last. This will dictate to give response in XML format. Then, we have created an object of RestTemplate class to use its APIs. We have used getForObject(uri, String.class) api which is used for doing GET request on the passed URI and asking for a response to be captured in the mentioned second argument. 
Note:
1.	For getting the response in JSON format, all we need to do is to change to extension in the URI from XML to JSON. 
2.	For getting the response in the form of an object rather than string, all we need to do is to capture the result as object of that type and changing the argument passed like below:
Employee employee = restTemplate.getFprObject(uri, Employee.class);
Case 2: For sending custom headers with the Request
We can also send some header attribute along with the request to web service. We can do it like below:

private static void getEmployees()
{
    final String uri = "http://localhost:8080/springrestexample/employees";
    RestTemplate restTemplate = new RestTemplate();
    HttpHeaders headers = new HttpHeaders();
    headers.setAccept(Arrays.asList(MediaType.APPLICATION_JSON));
    HttpEntity<String> entity = new HttpEntity<String>("parameters", headers);
    ResponseEntity<String> result = restTemplate.exchange(uri, HttpMethod.GET, entity, String.class);
    System.out.println(result);
}
Here, apart from all the basic stuff, we have created HttpHeader object and used setter methods for setting certain header attributes. The 

RRRCase 3: for having variable in URI
In case, we have a variable in the URI then we need to create a map which will be param and that param map need to be passed in the getForObject() method like below:
private static void getEmployeeById()
{
    final String uri = "http://localhost:8080/springrestexample/employees/{id}";   
    Map<String, String> params = new HashMap<String, String>();
    params.put("id", "1");
    RestTemplate restTemplate = new RestTemplate();
    EmployeeVO result = restTemplate.getForObject(uri, EmployeeVO.class, params);
    System.out.println(result);
}

Case 4: For sending other request method, we have different API in restTemplate like for POST method we have postForObject(), for PUT method we have put(). RestTemplate has lot to offer. 

19.	What will you do for making your spring web service hosted on HTTPS url?
The straight concept of converting your website to support https is to convert all the URLs from http to https is to purchase ssl certificate and configure it on the server. Generally. Hosting server providers on which you host your web service does it all for you with some charges. Even if you deploy your web service on cloud then you may see option of converting you web service to HTTPS. 
My previous experience of HTTP to HTTPS is with a web application where server or build team has installed ssl certificate on the server and we need to made all the links from Http to https. However, we noticed a lot of things were then got hampered as it did not allow untrusted media or script on https page. Then, we had to fix all those issues. 

20.	What basic POM dependencies you need for creating Spring Rest webservice?
Spring-webmvc is the main jar that you would always like to have while developing a spring rest web service. Spring-webmvc has dependency on spring-web and thus if we put dependency of spring-webmvc then spring-web will automatically by downloaded. I guess most frequent annotation used are actually in sping-web.
Then, spring-core is another important jar that you would want to add in your project to code related to dependency injection in spring project. Spring context is another jar which is related to dependency injection. Spring-context has transitive dependency in spring-core and thus we place dependency of spring-context then spring-core will also get downloaded automatically. 
Note: we must declare dependency of every jar that our written code is using even if it is transitive dependency of other jar. This is because may be in future the transitive dependency will no longer exist between two jars. In this scenario, our code will break due to missing jar. 
